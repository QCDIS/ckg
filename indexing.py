data = [{"source":"CUDA_Programming_Organisation","target":"CUDA_Execution_Flow"},{"source":"CUDA_Programming_Organisation","target":"CUDA_Memory_Allocation"},{"source":"Distributed_System","target":"Decentralised_System"},{"source":"Distributed_System","target":"Centralised_System"},{"source":"Decentalised_Application","target":"Client_Server"},{"source":"Decentalised_Application","target":"Blockchain"},{"source":"Decentalised_Application","target":"Ethereum_based_dApp"},{"source":"Multithread_Challenges","target":"Multithread_Challenge_Synchronization"},{"source":"Multithread_Challenges","target":"Multithread_Challenge_Parallelism"},{"source":"Multithread_Challenges","target":"Multithread_Challenge_Communication"},{"source":"Web_Service_Reference_Framework","target":"Web_Service_State"},{"source":"Ethereum_Virtual_Machine","target":"Ethereum_GAS"},{"source":"PMM_Shared_Memory","target":"PMM_Shared_Memory_Software_Cache"},{"source":"Memory_Spaces","target":"Multiple_Device_Memory_Scopes"},{"source":"Parallelism","target":"Dennard_scaling"},{"source":"Parallelism","target":"Single_Core"},{"source":"Parallelism","target":"Moores_Law"},{"source":"Parallelism","target":"Parallelism_Challenges"},{"source":"Parallelism","target":"Gustafsons_Law"},{"source":"Parallelism","target":"Parallelism_Levels"},{"source":"Parallelism","target":"Parallel_Machine_Model"},{"source":"Parallelism","target":"Amdahls_Law"},{"source":"Parallelism","target":"Multi_Core"},{"source":"Multiple_Device_Memory_Scopes","target":"Memory_Consistency"},{"source":"OpenMP_Programming_Models","target":"OpenMP_Thread_Scheduling"},{"source":"OpenMP_Programming_Models","target":"OpenMP_Loop_Scheduling"},{"source":"Hadoop_Ecosystem","target":"HDFS"},{"source":"Parallelism_Levels","target":"Data_Level_Parallelism"},{"source":"Parallelism_Levels","target":"Data_Task_Level_Parallelism"},{"source":"Parallelism_Levels","target":"Instruction_Level_Parallelism"},{"source":"Distributed_and_Parallel_Programming","target":"Parallel_Programming"},{"source":"Spark_RDD","target":"Spark_RDD_Operations"},{"source":"Parallelism_Challenges","target":"Parallelism_Challenges_Design_Complexity"},{"source":"Parallelism_Challenges","target":"Parallelism_Challenges_Power"},{"source":"Web_Service","target":"RESTful_Web_service"},{"source":"Web_Service","target":"Web_Service_Reference_Framework"},{"source":"Web_Service","target":"SOAP_Based_Web_Services"},{"source":"Web_Service","target":"Web_Service_Addressing"},{"source":"Multi_Core","target":"Dark_Silicon"},{"source":"Multi_Core","target":"Multi_Core_Scheduling"},{"source":"Multi_Core","target":"CPU"},{"source":"Multi_Core","target":"Multi_Core_Performance"},{"source":"Multi_Core","target":"Hardware_Performance_Metrics"},{"source":"Multi_Core","target":"GPU"},{"source":"Multi_Core","target":"Multithreads"},{"source":"Locking","target":"Livelock"},{"source":"Locking","target":"Deadlock"},{"source":"Hash_function","target":"SHA256"},{"source":"Multithread_Programming_Models","target":"PThread_Programming_Models"},{"source":"Multithread_Programming_Models","target":"OpenMP_Programming_Models"},{"source":"GPU_Programming_Model_CUDA","target":"CUDA_Parallelism_Model"},{"source":"Distributed_Ledger_Transaction","target":"Distributed_Ledger_Transaction_Concensus"},{"source":"Service_Oriented_Architecture_Model","target":"SOA_Model_Requester"},{"source":"Service_Oriented_Architecture_Model","target":"SOA_Model_Provider"},{"source":"Service_Oriented_Architecture_Model","target":"SOA_Model_Registry"},{"source":"MPI_Organisation_Principle","target":"MPI_Communication"},{"source":"MPI_Organisation_Principle","target":"MPI_Routines"},{"source":"Bitcoin","target":"Bitcoin_Nonce"},{"source":"Thread_Synchronisation","target":"Barriers"},{"source":"Ethereum","target":"Ethereum_based_dApp"},{"source":"Single_Core","target":"Single_Core_Performance_Scaling"},{"source":"Message_Passing_Interface","target":"MPI_Type_Matching"},{"source":"Message_Passing_Interface","target":"MPI_Datatype"},{"source":"Message_Passing_Interface","target":"MPI_Organisation_Principle"},{"source":"GPU_Atomic_Operations","target":"GPU_Atomics"},{"source":"GPU_Parallelisation","target":"GPU_Parallelisation_Vector_ADD"},{"source":"Spark_D_Stream","target":"Spark_D_Stream_Transformations"},{"source":"Parallel_Machine_Model","target":"PMM_Distributed_Memory"},{"source":"Parallel_Machine_Model","target":"PMM_Shared_Memory"},{"source":"Parallel_Machine_Model","target":"PMM_Virtual_Shared_Memory"},{"source":"Parallel_Machine_Model","target":"PMM_Hybrid_Memory"},{"source":"Client_Server","target":"P2P"},{"source":"Client_Server","target":"Master_Slave"},{"source":"Instruction_Level_Parallelism","target":"ILP_Scaling"},{"source":"P2P","target":"P2P_Unstructured"},{"source":"P2P","target":"P2P_Structured"},{"source":"Blockchain","target":"Blockchain_Wallet"},{"source":"Blockchain","target":"Proof_Of_Work"},{"source":"Blockchain","target":"Blockchain_Classification"},{"source":"Apache_Spark","target":"Apache_Spark_Model"},{"source":"Distributed_Memory_Systems","target":"Message_Passing_Interface"},{"source":"Multi_Core_Scheduling","target":"Block_Scheduling"},{"source":"Multi_Core_Scheduling","target":"Warp_Scheduling"},{"source":"Apache_Spark_Model","target":"Spark_RDD"},{"source":"Apache_Spark_Model","target":"Spark_Streaming"},{"source":"Ethereum_based_dApp","target":"Smart_Contract"},{"source":"Ethereum_based_dApp","target":"Ethereum_Virtual_Machine"},{"source":"Service_Oriented_Architecture","target":"Web_Service"},{"source":"Service_Oriented_Architecture","target":"Service_Oriented_Architecture_Model"},{"source":"MapReduce","target":"MapReduce_Programming_Model"},{"source":"MapReduce","target":"Apache_Spark"},{"source":"MapReduce","target":"HDFS"},{"source":"GPU_Programming_Models","target":"GPU_Programming_Model_CUDA"},{"source":"GPU_Programming_Models","target":"GPU_Programming_Model_OpenCL"},{"source":"Smart_Contract","target":"Smart_Contract_Development"},{"source":"Smart_Contract","target":"Smart_Contract_Language"},{"source":"Smart_Contract","target":"Smart_Contract_Operation"},{"source":"Smart_Contract","target":"Smart_Contract_State_Machine_View"},{"source":"Smart_Contract","target":"Smart_Contract_Deployment"},{"source":"Smart_Contract","target":"Smart_Contract_Execution"},{"source":"Web_Service_State","target":"Web_Service_State_Stateless"},{"source":"Web_Service_State","target":"Web_Service_State_Stateful"},{"source":"Multithreads","target":"Thread_Synchronisation"},{"source":"Multithreads","target":"Multithread_Thread_Divergence"},{"source":"Multithreads","target":"Locking"},{"source":"Multithreads","target":"Multithread_Programming_Models"},{"source":"Multithreads","target":"Multithread_Challenges"},{"source":"Blockchain_Technologies","target":"Bitcoin"},{"source":"Blockchain_Technologies","target":"IOTA"},{"source":"Blockchain_Technologies","target":"Ethereum"},{"source":"Blockchain_Technologies","target":"Hyperledger_Fabric"},{"source":"Warp_Scheduling","target":"Stalling_Warps"},{"source":"Warp_Scheduling","target":"Warp_Occupancy"},{"source":"Decentralised_System","target":"Distributed_Ledger"},{"source":"Spark_Streaming","target":"Spark_D_Stream"},{"source":"Spark_Streaming","target":"Spark_Window_Operations"},{"source":"PThread_Programming_Models","target":"Multithread_Race_Condition"},{"source":"MPI_Communication","target":"MPI_Synchronised_Communication"},{"source":"MPI_Communication","target":"MPI_point2point_Communication"},{"source":"MPI_Communication","target":"MPI_Asynchronised_Communication"},{"source":"Distributed_Ledger","target":"Distributed_Ledger_Business"},{"source":"Distributed_Ledger","target":"Distributed_Ledger_Challenges"},{"source":"Distributed_Ledger","target":"Blockchain"},{"source":"Distributed_Ledger","target":"Distributed_Ledger_Transaction"},{"source":"MapReduce_Programming_Model","target":"MRPM_Distributed_Execution"},{"source":"MapReduce_Programming_Model","target":"MRPM_Partition_Function"},{"source":"MapReduce_Programming_Model","target":"MRPM_Dataflow"},{"source":"MapReduce_Programming_Model","target":"Master_Slave"},{"source":"Memory","target":"Multiple_Device_Memory_Scopes"},{"source":"Memory","target":"CUDA_Memory_Allocation"},{"source":"Memory","target":"Memory_Coalescing"},{"source":"Memory","target":"Memory_Caching"},{"source":"Barriers","target":"Global_Barrier"},{"source":"Barriers","target":"Block_Level_Barrier"},{"source":"GPU","target":"GPU_Parallelisation"},{"source":"GPU","target":"GPU_Architecture"},{"source":"GPU","target":"GPU_Programming"},{"source":"GPU","target":"GPU_Atomic_Operations"},{"source":"GPU","target":"GPU_Optimisation"},{"source":"Smart_Contract_Language","target":"Smart_Contract_Language_Solidity"},{"source":"Master_Slave","target":"Master_Slave_Coordination"},{"source":"Parallel_Programming","target":"Parallelism"},{"source":"Parallel_Programming","target":"Parallel_Thinking"}]

def build_tree(data, parent=None):
    tree = {}
    
    # Filtering items based on current parent (source)
    items = [item for item in data if item["source"] == parent]
    
    # If no items found, return parent itself (this is the base case for recursion)
    if not items:
        return parent
    
    # Otherwise, build tree for each item
    for item in items:
        tree[item["source"]] = tree.get(item["source"], []) + [build_tree(data, item["target"])]
    
    return tree

# Initialize tree using items that are sources but not targets (root nodes)
root_sources = set(item["source"] for item in data) - set(item["target"] for item in data)

json_tree = {}
for root in root_sources:
    json_tree[root] = build_tree(data, root)

print(json_tree)